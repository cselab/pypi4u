{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to Pi4U\n\n\nPi4U is a HPC framework for Bayesian uncertainty quantification of large scale computational models.\n\n\nModules and algorithms\n\n\nInference\n\n\nTMCMC\n\n\nABC-Subsim\n\n\nDRAM\n\n\nSingle-objective optimization\n\n\nCMAES\n\n\nAmalgam\n\n\nMulti-objective optimization\n\n\nNSGA-II\n\n\nMOCMAES\n\n\nMOEAD\n\n\nImplementations\n\n\nParallel\n\n\nSequential",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-pi4u",
            "text": "Pi4U is a HPC framework for Bayesian uncertainty quantification of large scale computational models.",
            "title": "Welcome to Pi4U"
        },
        {
            "location": "/#modules-and-algorithms",
            "text": "",
            "title": "Modules and algorithms"
        },
        {
            "location": "/#inference",
            "text": "TMCMC  ABC-Subsim  DRAM",
            "title": "Inference"
        },
        {
            "location": "/#single-objective-optimization",
            "text": "CMAES  Amalgam",
            "title": "Single-objective optimization"
        },
        {
            "location": "/#multi-objective-optimization",
            "text": "NSGA-II  MOCMAES  MOEAD",
            "title": "Multi-objective optimization"
        },
        {
            "location": "/#implementations",
            "text": "",
            "title": "Implementations"
        },
        {
            "location": "/#parallel",
            "text": "",
            "title": "Parallel"
        },
        {
            "location": "/#sequential",
            "text": "",
            "title": "Sequential"
        },
        {
            "location": "/python/",
            "text": "Python interface of TMCMC\n\n\nModule tmcmc implements the TMCMC (Transitional Markov-Chain Monte Carlo) algorithm.\n\n\nWe use the C implementation of the algorithm and the \nctypes wrapper\n module for calling it from Python.\nSince the function we are sampling from is also written in Python, we use \nembedded Python\n to call the\nfunction from the C code and \nnumpy\n to pass arguments between the two environments.\n\n\nTMCMC\n\n\nThe Python interface of TMCMC is defined as follows:\n\n\ndef tmcmc(fitfun, dim=2, maxstages=20, popsize=1024, lowerbound=[-6,-6], upperbound=[6,6], id=0):\n\n\nInputs:\n\n\n\n\nfitfun\n: python script name (without the .py extension) that implements the log-likelihood function.\nThe prototype is: fitfun(x, dim), where \nx\n is a vector of parameter values and \ndim\n the number of parameters.\n\n\ndim\n: number of parameters\n\n\nmaxstages\n: maximum number of stages that can be performed by the TMCMC algorithm\n\n\npopsize\n: number of samples per stage\n\n\nlowerbound\n: lower bound for each parameter\n\n\nupperbound\n: uppoer bound for each parameter\n\n\nid\n: integer identifier for the specific \ntmcmc()\n call. The value is appended to the output files generated by the algorithm.\n\n\n\n\nOutputs:\n\n\n\n\nThe tmcmc function returns the log-evidence of the model.\n\n\nIn addition, for each stage of the algorithm, the evaluation points and their log-likelihood are stored in text files\nnamed as \ncurgen_db_xxx_yyy.txt\n, where \nxxx\n: \nid\n of the \ntmcmc()\n call, and \nyyy\n: stage of the algorithm.\n\n\n\n\nFitness function\n\n\nThe fitness function typically computes the model output and \nreturns\n the log-likelihood of the data.\n\n\ndef fitfun(theta, dim):\n\n\n\n\ntheta\n: parameters of the model\n\n\ndim\n: number of parameters\n\n\n\n\nPlotting\n\n\n2D scatter plots of the samples stored in the output text files, colored according to their log-likelihood values,\ncan be produced by means of the \nplot_gen()\n function.\n\n\ndef plot_gen(filename, dim=2, i=1, j=2, show=1, save=0):\n\n\n\n\nfilename\n: curgen_db_xxx_yyy.txt file\n\n\ndim\n: number of parameters\n\n\ni\n: i-th parameter\n\n\nj\n: j-th parameter\n\n\nnamei\n: label for the i-th parameter\n\n\nnamej\n: label for the j-th parameter\n\n\nshow\n: depict the plot on the screen\n\n\nsave\n: save the plot in a png file (filename.png)\n\n\n\n\nExample\n\n\ndemo3.py\n\n\n# Import necessary modules\nimport sys\nsys.path.append(\"../lib_python\")\nfrom tmcmc import *\nfrom plot_gen import *\n\nlogEv=tmcmc(\"fitfun3\",dim=2,maxstages=20,popsize=4096,lowerbound=[-10,-10],upperbound=[10,10],id=3)\nprint(\"logEv=\",logEv[0])\n\nplot_gen('curgen_db_003_009.txt', dim=2, i=1, j=2, namei='alpha', namej='sigma^2', show=1, save=0)\n\n\n\nfitfun3.py\n\n\n# data-driven inference\n# underlying data model: y = ax + e, where\n# a=0.3 and e=N(0,sigma^2), sigma=0.1\n\nimport numpy as np\nimport math\n\ndef fitfun3(theta, dim):\n\n    a = theta[0]\n    sigma = theta[1]\n\n    data = np.loadtxt('data3.txt')\n    N=data.shape[0];\n\n    x = data[:,0]\n    dy = data[:,1]\n\n    y = a*x;\n\n    SSE = np.sum((y-dy)\\*\\*2)\n    sy=sigma;\n    logn = -0.5*N*math.log(2*math.pi)-0.5*N*math.log(sy*sy)-0.5*SSE/(sy*sy)\n\n    return logn\n\n\n\nInstallation and testing\n\n\nPrerequisites\n\n\nMake sure that the following required software has been installed.\n\n\n\n\nGCC compiler\n\n\nPython 2.7 (or higher)\n\n\nPython-devel package\n\n\npython2-config\n or \npython3-config\n must be available\n\n\nMacOS: automatically available if python has been installed with brew\n\n\n\n\n\n\nPython numpy package\n\n\nMacOS: \npip2 install numpy\n or \npip3 install numpy\n\n\n\n\n\n\nPython matplotlib package\n\n\nMacOS: \npip2 install matplotlib\n or \npip3 install matplotlib\n\n\n\n\n\n\nGNU GSL library\n\n\nMacOS: \nbrew install gsl\n\n\nWe also provide the option to download and use a local copy of the GSL library\n\n\n\n\n\n\n\n\nInstallation steps\n\n\n1. Download from GitHub:\n\n\ngit clone https://github.com/cselab/pi4u.git pi4u-tmcmc -b tmcmc\n\n\nIf you do not have git, download \npi4u-tmcmc.zip\n from here: \nGitHub download link\n\n\n2. Go to pi4u-tmcmc/src and build the TMCMC library:\n\n\ncd pi4u-tmcmc/src; make\n\n\ncd ..\n  (\ngo back to the pi4u-tmcmc directory\n)\n\n\nTesting - Running the demo\n\n\n1. Go to pi4u-tmcmc/demo_python and run demo3.py\n\n\ncd demo_python; python2 demo3.py\n  \n\n\n2. The scatter plot of samples for our example should be as follows:\n\n\n\n\nTroubleshooting and additional options\n\n\nHow to build the software using a local copy of the GSL library\n\n\n1. Go to pi4u-tmcmc/gsl and run build.sh:\n\n\ncd pi4u-tmcmc/gsl; ./build.sh\n\n\ncd ..\n  (\ngo back to the pi4u-tmcmc directory\n)\n\n\n2. Go to pi4u-tmcmc/src and build the TMCMC library:\n\n\ncd src; make -B mygsl=1\n\n\nHow to build the software using python3\n\n\n1. Go to pi4u-tmcmc/src and (re)-build the TMCMC library:\n\n\nmake -B python3=1\n\n\ncd ..\n  (\ngo back to the pi4u-tmcmc directory\n)\n\n\n2. Go to demo_python and run demo3.py using python3\n\n\ncd demo_python; python3 demo3.py",
            "title": "Python"
        },
        {
            "location": "/python/#python-interface-of-tmcmc",
            "text": "Module tmcmc implements the TMCMC (Transitional Markov-Chain Monte Carlo) algorithm.  We use the C implementation of the algorithm and the  ctypes wrapper  module for calling it from Python.\nSince the function we are sampling from is also written in Python, we use  embedded Python  to call the\nfunction from the C code and  numpy  to pass arguments between the two environments.",
            "title": "Python interface of TMCMC"
        },
        {
            "location": "/python/#tmcmc",
            "text": "The Python interface of TMCMC is defined as follows:  def tmcmc(fitfun, dim=2, maxstages=20, popsize=1024, lowerbound=[-6,-6], upperbound=[6,6], id=0):  Inputs:   fitfun : python script name (without the .py extension) that implements the log-likelihood function.\nThe prototype is: fitfun(x, dim), where  x  is a vector of parameter values and  dim  the number of parameters.  dim : number of parameters  maxstages : maximum number of stages that can be performed by the TMCMC algorithm  popsize : number of samples per stage  lowerbound : lower bound for each parameter  upperbound : uppoer bound for each parameter  id : integer identifier for the specific  tmcmc()  call. The value is appended to the output files generated by the algorithm.   Outputs:   The tmcmc function returns the log-evidence of the model.  In addition, for each stage of the algorithm, the evaluation points and their log-likelihood are stored in text files\nnamed as  curgen_db_xxx_yyy.txt , where  xxx :  id  of the  tmcmc()  call, and  yyy : stage of the algorithm.",
            "title": "TMCMC"
        },
        {
            "location": "/python/#fitness-function",
            "text": "The fitness function typically computes the model output and  returns  the log-likelihood of the data.  def fitfun(theta, dim):   theta : parameters of the model  dim : number of parameters",
            "title": "Fitness function"
        },
        {
            "location": "/python/#plotting",
            "text": "2D scatter plots of the samples stored in the output text files, colored according to their log-likelihood values,\ncan be produced by means of the  plot_gen()  function.  def plot_gen(filename, dim=2, i=1, j=2, show=1, save=0):   filename : curgen_db_xxx_yyy.txt file  dim : number of parameters  i : i-th parameter  j : j-th parameter  namei : label for the i-th parameter  namej : label for the j-th parameter  show : depict the plot on the screen  save : save the plot in a png file (filename.png)",
            "title": "Plotting"
        },
        {
            "location": "/python/#example",
            "text": "",
            "title": "Example"
        },
        {
            "location": "/python/#demo3py",
            "text": "# Import necessary modules\nimport sys\nsys.path.append(\"../lib_python\")\nfrom tmcmc import *\nfrom plot_gen import *\n\nlogEv=tmcmc(\"fitfun3\",dim=2,maxstages=20,popsize=4096,lowerbound=[-10,-10],upperbound=[10,10],id=3)\nprint(\"logEv=\",logEv[0])\n\nplot_gen('curgen_db_003_009.txt', dim=2, i=1, j=2, namei='alpha', namej='sigma^2', show=1, save=0)",
            "title": "demo3.py"
        },
        {
            "location": "/python/#fitfun3py",
            "text": "# data-driven inference\n# underlying data model: y = ax + e, where\n# a=0.3 and e=N(0,sigma^2), sigma=0.1\n\nimport numpy as np\nimport math\n\ndef fitfun3(theta, dim):\n\n    a = theta[0]\n    sigma = theta[1]\n\n    data = np.loadtxt('data3.txt')\n    N=data.shape[0];\n\n    x = data[:,0]\n    dy = data[:,1]\n\n    y = a*x;\n\n    SSE = np.sum((y-dy)\\*\\*2)\n    sy=sigma;\n    logn = -0.5*N*math.log(2*math.pi)-0.5*N*math.log(sy*sy)-0.5*SSE/(sy*sy)\n\n    return logn",
            "title": "fitfun3.py"
        },
        {
            "location": "/python/#installation-and-testing",
            "text": "",
            "title": "Installation and testing"
        },
        {
            "location": "/python/#prerequisites",
            "text": "Make sure that the following required software has been installed.   GCC compiler  Python 2.7 (or higher)  Python-devel package  python2-config  or  python3-config  must be available  MacOS: automatically available if python has been installed with brew    Python numpy package  MacOS:  pip2 install numpy  or  pip3 install numpy    Python matplotlib package  MacOS:  pip2 install matplotlib  or  pip3 install matplotlib    GNU GSL library  MacOS:  brew install gsl  We also provide the option to download and use a local copy of the GSL library",
            "title": "Prerequisites"
        },
        {
            "location": "/python/#installation-steps",
            "text": "1. Download from GitHub:  git clone https://github.com/cselab/pi4u.git pi4u-tmcmc -b tmcmc  If you do not have git, download  pi4u-tmcmc.zip  from here:  GitHub download link  2. Go to pi4u-tmcmc/src and build the TMCMC library:  cd pi4u-tmcmc/src; make  cd ..   ( go back to the pi4u-tmcmc directory )",
            "title": "Installation steps"
        },
        {
            "location": "/python/#testing-running-the-demo",
            "text": "1. Go to pi4u-tmcmc/demo_python and run demo3.py  cd demo_python; python2 demo3.py     2. The scatter plot of samples for our example should be as follows:",
            "title": "Testing - Running the demo"
        },
        {
            "location": "/python/#troubleshooting-and-additional-options",
            "text": "",
            "title": "Troubleshooting and additional options"
        },
        {
            "location": "/python/#how-to-build-the-software-using-a-local-copy-of-the-gsl-library",
            "text": "1. Go to pi4u-tmcmc/gsl and run build.sh:  cd pi4u-tmcmc/gsl; ./build.sh  cd ..   ( go back to the pi4u-tmcmc directory )  2. Go to pi4u-tmcmc/src and build the TMCMC library:  cd src; make -B mygsl=1",
            "title": "How to build the software using a local copy of the GSL library"
        },
        {
            "location": "/python/#how-to-build-the-software-using-python3",
            "text": "1. Go to pi4u-tmcmc/src and (re)-build the TMCMC library:  make -B python3=1  cd ..   ( go back to the pi4u-tmcmc directory )  2. Go to demo_python and run demo3.py using python3  cd demo_python; python3 demo3.py",
            "title": "How to build the software using python3"
        },
        {
            "location": "/matlab/",
            "text": "Matlab interface of TMCMC",
            "title": "Matlab"
        },
        {
            "location": "/matlab/#matlab-interface-of-tmcmc",
            "text": "",
            "title": "Matlab interface of TMCMC"
        },
        {
            "location": "/rlib/",
            "text": "R interface of TMCMC",
            "title": "R"
        },
        {
            "location": "/rlib/#r-interface-of-tmcmc",
            "text": "",
            "title": "R interface of TMCMC"
        },
        {
            "location": "/hpc/",
            "text": "Software layout\n\n\ntorc_lite    # TORC tasking library\npndl         # Parallel numerical differentation library\nengines/      # UQ + OPT algorithms\n    engine_tmcmc # TMCMC\n    engine_cmaes # CMAES\n    ...          #\nABC_SubSim   # ABC Subset simulation algorithm\nAMaLGaM      # Stochastic optimization algorithm",
            "title": "C/C++"
        },
        {
            "location": "/hpc/#software-layout",
            "text": "torc_lite    # TORC tasking library\npndl         # Parallel numerical differentation library\nengines/      # UQ + OPT algorithms\n    engine_tmcmc # TMCMC\n    engine_cmaes # CMAES\n    ...          #\nABC_SubSim   # ABC Subset simulation algorithm\nAMaLGaM      # Stochastic optimization algorithm",
            "title": "Software layout"
        },
        {
            "location": "/about/",
            "text": "Pi4U - High Performance UQ+OPT Framework\n\n\nPi4U  is our HPC framework for Bayesian uncertainty quantification of large scale computational models.\n\n\nSoftware\n\n\n\n\nThe latest version of the Pi4U framework can be downloaded from here:\n\npi4u_0.4.1.tar.gz\n (22.03.2016)\n\n\nPrevious public version: \npi4u_0.2.tar.gz\n\n\n\n\nAdditional documentation\n\n\n\n\nTutorial: \npdf\n\n\nPoster about Pi4U: \npdf\n\n\nPresentation at the Europar 2015 conference: \npdf\n\n\n\n\nRelated publications\n\n\nPi4U framework\n\n\n\n\nHadjidoukas P.E., Angelikopoulos P., Papadimitriou C., Koumoutsakos P., Pi4U: A high performance computing framework for Bayesian uncertainty quantification of complex models. J. Comput. Phys., 284:1-21, 2015\n(\ndoi\n,\npdf\n)\n\n\nHadjidoukas P.E., Angelikopoulos P., Kulakova L., Papadimitriou C., Koumoutsakos P., Exploiting Task-Based Parallelism in Bayesian Uncertainty Quantification. EuroPar 2015, LLCS 2015, 9233, 532\n(\ndoi\n,\npdf\n)\n\n\n\n\nApplications\n\n\n\n\n\n\nKulakova L., Angelikopoulos P., Hadjidoukas P. E., Papadimitriou C., Koumoutsakos P., Approximate Bayesian Computation for Granular and Molecular Dynamics Simulations. Proceedings of the Platform for Advanced Scientific Computing Conference PASC'16, 2016\n(\ndoi\n, \npdf\n)\n\n\n\n\n\n\nHadjidoukas P.E, Angelikopoulos P., Rossinelli D., Alexeev D., Papadimitriou C., Koumoutsakos P., Bayesian uncertainty quantification and propagation for discrete element simulations of granular materials. Comput. Methods Appl. Mech. Engrg., 282:218-238, 2014\n(\ndoi\n,\npdf\n)\n\n\n\n\n\n\nTORC: Task-Based Runtime Library\n\n\n\n\nHadjidoukas P.E., Lappas E., Dimakopoulos V.V: A Runtime Library for Platform-Independent Task Parallelism. PDP 2012: 229-236\n(\ndoi\n)",
            "title": "About"
        },
        {
            "location": "/about/#pi4u-high-performance-uqopt-framework",
            "text": "Pi4U  is our HPC framework for Bayesian uncertainty quantification of large scale computational models.",
            "title": "Pi4U - High Performance UQ+OPT Framework"
        },
        {
            "location": "/about/#software",
            "text": "The latest version of the Pi4U framework can be downloaded from here: pi4u_0.4.1.tar.gz  (22.03.2016)  Previous public version:  pi4u_0.2.tar.gz",
            "title": "Software"
        },
        {
            "location": "/about/#additional-documentation",
            "text": "Tutorial:  pdf  Poster about Pi4U:  pdf  Presentation at the Europar 2015 conference:  pdf",
            "title": "Additional documentation"
        },
        {
            "location": "/about/#related-publications",
            "text": "",
            "title": "Related publications"
        },
        {
            "location": "/about/#pi4u-framework",
            "text": "Hadjidoukas P.E., Angelikopoulos P., Papadimitriou C., Koumoutsakos P., Pi4U: A high performance computing framework for Bayesian uncertainty quantification of complex models. J. Comput. Phys., 284:1-21, 2015\n( doi , pdf )  Hadjidoukas P.E., Angelikopoulos P., Kulakova L., Papadimitriou C., Koumoutsakos P., Exploiting Task-Based Parallelism in Bayesian Uncertainty Quantification. EuroPar 2015, LLCS 2015, 9233, 532\n( doi , pdf )",
            "title": "Pi4U framework"
        },
        {
            "location": "/about/#applications",
            "text": "Kulakova L., Angelikopoulos P., Hadjidoukas P. E., Papadimitriou C., Koumoutsakos P., Approximate Bayesian Computation for Granular and Molecular Dynamics Simulations. Proceedings of the Platform for Advanced Scientific Computing Conference PASC'16, 2016\n( doi ,  pdf )    Hadjidoukas P.E, Angelikopoulos P., Rossinelli D., Alexeev D., Papadimitriou C., Koumoutsakos P., Bayesian uncertainty quantification and propagation for discrete element simulations of granular materials. Comput. Methods Appl. Mech. Engrg., 282:218-238, 2014\n( doi , pdf )",
            "title": "Applications"
        },
        {
            "location": "/about/#torc-task-based-runtime-library",
            "text": "Hadjidoukas P.E., Lappas E., Dimakopoulos V.V: A Runtime Library for Platform-Independent Task Parallelism. PDP 2012: 229-236\n( doi )",
            "title": "TORC: Task-Based Runtime Library"
        }
    ]
}